#include "MultiGraph.h"
#include "Exceptions.h"
#include "IntPair.h"
#include <iostream>
#include <iomanip>
#include <fstream>

//=======================//
// Implemented Functions //
//=======================//
MultiGraph::MultiGraph()
{}

MultiGraph::MultiGraph(const std::string& filePath)
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    // Tokens
    std::string tokens[5];
    std::ifstream mapFile(filePath.c_str());

    if(!mapFile.is_open())
    {
        std::cout << "Unable to open " << filePath << std::endl;
        return;
    }

    // Read line by line
    std::string line;
    while (std::getline(mapFile, line))
    {
        // Empty Line Skip
        if(line.empty()) continue;
        // Comment Skip
        if(line[0] == '#') continue;

        // Tokenize the line
        int i = 0;
        std::istringstream stream(line);
        while(stream >> tokens[i]) i++;

        // Single token (Meaning it is a vertex)
        if(i == 1)
        {
            InsertVertex(tokens[0]);
        }
        // Exactly 5 tokens (Meaning it is an edge)
        else if(i == 5)
        {
            // Rename vars for readablity
            const std::string& vertexFromName = tokens[0];
            const std::string& vertexToName = tokens[1];
            const std::string& edgeName = tokens[2];
            float weight0 = static_cast<float>(std::atof(tokens[3].c_str()));
            float weight1 = static_cast<float>(std::atof(tokens[4].c_str()));
            AddEdge(edgeName, vertexFromName, vertexToName,
                    weight0, weight1);
        }
        else std::cerr << "Token Size Mismatch" << std::endl;
    }
}

void MultiGraph::PrintPath(const std::vector<int>& orderedVertexEdgeIndexList,
                           float heuristicWeight,
                           bool sameLine) const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this file !       //
    // ============================= //

    // Name is too long
    const std::vector<int>& ove = orderedVertexEdgeIndexList;
    // Invalid list
    // At least three items should be available
    if(ove.size() < 3) return;

    // Check vertex and an edge
    for(size_t i = 0; i < orderedVertexEdgeIndexList.size(); i += 2)
    {
        int vertexId = ove[i];
        if(vertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                      << " not found!" << std::endl;
            return;
        }


        const GraphVertex& vertex = vertexList[vertexId];
        std::cout << vertex.name;
        if(!sameLine) std::cout << "\n";
        // Only find and print the weight if next is available
        if(i == ove.size() - 1) break;
        int nextVertexId = ove[i + 2];
        if(nextVertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                    << " not found!" << std::endl;
            return;
        }

        // Find the edge between these two vertices
        int localEdgeId = ove[i + 1];
        if(localEdgeId >= static_cast<int>(vertex.edges.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "EdgeId " << localEdgeId
                      << " not found in " << vertexId << "!" << std::endl;
            return;
        }

        const GraphEdge& edge = vertex.edges[localEdgeId];

        // Combine with heuristic (linear interpolation)
        float weight = Lerp(edge.weight[0], edge.weight[1],
                            heuristicWeight);

        std::cout << "-" << std::setfill('-')
                  << std::setw(4)
                  << weight << "->";
    }
    // Print endline on the last vertex if same line is set
    if(sameLine) std::cout << "\n";
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

void MultiGraph::PrintEntireGraph() const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    for(size_t i = 0; i < vertexList.size(); i++)
    {
        const GraphVertex& v = vertexList[i];
        std::cout << v.name << "\n";
        for(size_t j = 0; j < v.edges.size(); j++)
        {
            const GraphEdge& edge = v.edges[j];

            // List the all vertex names and weight
            std::cout << "    -"
                      << std::setfill('-')
                      << std::setw(4) << edge.weight[0]
                      << "-"
                      << std::setw(4) << edge.weight[1]
                      << "-> ";
            std::cout << vertexList[edge.endVertexIndex].name;
            std::cout << " (" << edge.name << ")" << "\n";
        }
    }
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

//=======================//
//          TODO         //
//=======================//
float MultiGraph::Lerp(float w0, float w1, float alpha)
{
    /* TODO */
    return w0*(1.0-alpha) + w1*alpha;
}

void MultiGraph::InsertVertex(const std::string& vertexName)
{
    /* TODO */
    for(int i = 0; i < vertexList.size();i++){
        const GraphVertex& v = vertexList[i];
        if(v.name == vertexName){
            throw DuplicateVertexException(vertexName);
        }
    }
    std::vector<GraphEdge> newVertexEdges;
    GraphVertex newVertex;
    newVertex.name = vertexName;
    newVertex.edges = newVertexEdges;
    vertexList.push_back(newVertex);
}

void MultiGraph::RemoveVertex(const std::string& vertexName)
{
    /* TODO */
    for(int i = 0; i < vertexList.size(); i++){
        if(i == vertexList.size()-1 && vertexList[i].name != vertexName){
            throw VertexNotFoundException(vertexName);
        } else if (vertexList[i].name == vertexName){
            for(int j = 0; j < vertexList.size(); j++){
                GraphVertex& v = vertexList[j];
                for(int t = 0; t < v.edges.size(); t++){
                    if(v.edges[t].endVertexIndex == i){
                        v.edges.erase(v.edges.begin()+t);
                    }
                }
            }
            vertexList.erase(vertexList.begin()+i);
            break;
        }
    }
}

void MultiGraph::AddEdge(const std::string& edgeName,
                         const std::string& vertexFromName,
                         const std::string& vertexToName,
                         float weight0, float weight1)
{
    /* TODO */
    // Checking the errors
    int fromIndex = vertexIndexByName(vertexFromName);
    int endIndex = vertexIndexByName(vertexToName);
    
    if (fromIndex == -1) {
        throw VertexNotFoundException(vertexFromName);
    } else if (endIndex == -1) {
        throw VertexNotFoundException(vertexToName);
    }
    
    for(int t = 0; t < vertexList[fromIndex].edges.size(); t++){
        if(vertexList[fromIndex].edges[t].name == edgeName && vertexList[fromIndex].edges[t].endVertexIndex == endIndex){
            throw SameNamedEdgeException(edgeName, vertexFromName, vertexToName);
        }
    }
    
    GraphEdge newEdge;
    newEdge.name = edgeName;
    newEdge.weight[0] = weight0;
    newEdge.weight[1] = weight1;
    newEdge.endVertexIndex = endIndex;
    vertexList[fromIndex].edges.push_back(newEdge);
}

void MultiGraph::RemoveEdge(const std::string& edgeName,
                            const std::string& vertexFromName,
                            const std::string& vertexToName)
{
    /* TODO */
    int fromIndex = vertexIndexByName(vertexFromName);
    int endIndex = vertexIndexByName(vertexToName);
    
    if (fromIndex == -1) {
        throw VertexNotFoundException(vertexFromName);
    } else if (endIndex == -1) {
        throw VertexNotFoundException(vertexToName);
    }
    
    for(int t = 0; t < vertexList[fromIndex].edges.size(); t++){
        if(vertexList[fromIndex].edges[t].name != edgeName && t == vertexList[fromIndex].edges.size()-1){
            throw EdgeNotFoundException(vertexFromName, edgeName);
        } else if (vertexList[fromIndex].edges[t].name == edgeName){
            vertexList[fromIndex].edges.erase(vertexList[fromIndex].edges.begin()+t);
            break;
        }
    }
}

bool MultiGraph::HeuristicShortestPath(std::vector<int>& orderedVertexEdgeIndexList,
                                       const std::string& vertexNameFrom,
                                       const std::string& vertexNameTo,
                                       float heuristicWeight) const
{
    /* TODO */
    int inf = 99999999999;
    int fromIndex = vertexIndexByName(vertexNameFrom);
    int endIndex = vertexIndexByName(vertexNameTo);
    
    if (fromIndex == -1) {
        throw VertexNotFoundException(vertexNameFrom);
    } else if (endIndex == -1) {
        throw VertexNotFoundException(vertexNameTo);
    }
    
    std::vector<float> distArray(vertexList.size(), inf);
    std::vector<int> previousVertex(vertexList.size(), -1);
    std::vector<int> previousEdge(vertexList.size(), -1);
    MinPairHeap<float, int> helperQueue;
    distArray[fromIndex] = 0;
    helperQueue.push({0, fromIndex});

    while (!helperQueue.empty()) {
        float currentDist = helperQueue.top().key;
        int vertexIndex = helperQueue.top().value;
        helperQueue.pop();

        if (currentDist > distArray[vertexIndex]) {
            continue;
        }
    
        if (vertexIndex == endIndex) {
            break;
        }
    
        const GraphVertex& vertex = vertexList[vertexIndex];
        
        for (int i = 0; i < vertex.edges.size(); i++) {
            const GraphEdge& edge = vertex.edges[i];
            int neighborIndex = edge.endVertexIndex;
            float w = Lerp(edge.weight[0], edge.weight[1], heuristicWeight);
            float newDist = distArray[vertexIndex] + w;
    
            if (newDist < distArray[neighborIndex]) {
                distArray[neighborIndex] = newDist;
                previousVertex[neighborIndex] = vertexIndex;
                previousEdge[neighborIndex] = i;
                helperQueue.push({newDist, neighborIndex});
            }
        }
    }

    if (distArray[endIndex] == inf) {
        return false;
    }

    orderedVertexEdgeIndexList.clear();
    int at = endIndex;
    while (at != fromIndex) {
        int edgeIdx = previousEdge[at];
        orderedVertexEdgeIndexList.push_back(at);
        if (edgeIdx != -1) {
            orderedVertexEdgeIndexList.push_back(edgeIdx);
        }
        at = previousVertex[at];
    }
    orderedVertexEdgeIndexList.push_back(fromIndex);

    reverseVector(orderedVertexEdgeIndexList);

    return true;
}

bool MultiGraph::FilteredShortestPath(std::vector<int>& orderedVertexEdgeIndexList,
                                      const std::string& vertexNameFrom,
                                      const std::string& vertexNameTo,
                                      float heuristicWeight,
                                      const std::vector<std::string>& edgeNames) const
{
    /* TODO */
    int inf = 99999999999;
    int fromIndex = vertexIndexByName(vertexNameFrom);
    int endIndex = vertexIndexByName(vertexNameTo);
    
    if (fromIndex == -1) {
        throw VertexNotFoundException(vertexNameFrom);
    } else if (endIndex == -1) {
        throw VertexNotFoundException(vertexNameTo);
    }
    
    std::vector<float> distArray(vertexList.size(), inf);
    std::vector<int> previousVertex(vertexList.size(), -1);
    std::vector<int> previousEdge(vertexList.size(), -1);
    MinPairHeap<float, int> helperQueue;
    distArray[fromIndex] = 0;
    helperQueue.push({0, fromIndex});

    while (!helperQueue.empty()) {
        float currentDist = helperQueue.top().key;
        int vertexIndex = helperQueue.top().value;
        helperQueue.pop();
    
        if (currentDist > distArray[vertexIndex]) {
            continue;
        }
    
        if (vertexIndex == endIndex) {
            break;
        }
    
        const GraphVertex& vertex = vertexList[vertexIndex];
        
        for (int i = 0; i < vertex.edges.size(); i++) {
            const GraphEdge& edge = vertex.edges[i];
            int neighborIndex = edge.endVertexIndex;
            int count = 0;
            
            for(int j = 0; j < edgeNames.size(); j++){
                if(edgeNames[j] == edge.name){
                    count++;
                    break;
                }
            }
            
            if(count == 0){
                float w = Lerp(edge.weight[0], edge.weight[1], heuristicWeight);
                float newDist = distArray[vertexIndex] + w;
        
                if (newDist < distArray[neighborIndex]) {
                    distArray[neighborIndex] = newDist;
                    previousVertex[neighborIndex] = vertexIndex;
                    previousEdge[neighborIndex] = i;
                    helperQueue.push({newDist, neighborIndex});
                }
            }
        }
    }

    if (distArray[endIndex] == inf) {
        return false;
    }

    orderedVertexEdgeIndexList.clear();
    int at = endIndex;
    while (at != fromIndex) {
        int edgeIdx = previousEdge[at];
        orderedVertexEdgeIndexList.push_back(at);
        if (edgeIdx != -1) {
            orderedVertexEdgeIndexList.push_back(edgeIdx);
        }
        at = previousVertex[at];
    }
    orderedVertexEdgeIndexList.push_back(fromIndex); 

    reverseVector(orderedVertexEdgeIndexList);

    return true;
}

int MultiGraph::BiDirectionalEdgeCount() const
{
    /* TODO */
    int count = 0;
    for(int i = 0; i < vertexList.size(); i++){
        const GraphVertex& v1 = vertexList[i];
        for(int j = 0; j < v1.edges.size(); j++){
            const GraphVertex& v2 = vertexList[v1.edges[j].endVertexIndex];
            for(int t = 0; t < v2.edges.size(); t++){
                if(v1.edges[j].name == v2.edges[t].name && v2.edges[t].endVertexIndex == i){
                    if(i < v1.edges[j].endVertexIndex){
                        count++;
                        break;
                    }
                }
            }
        }
    }
    return count;
}

int MultiGraph::MaxDepthViaEdgeName(const std::string& vertexName,
                                    const std::string& edgeName) const
{
    /* TODO */
    int maxDepth = 0, vertexIndex = vertexIndexByName(vertexName);
    if (vertexIndex == -1) {
        throw VertexNotFoundException(vertexName);
    }
    
    MinPairHeap<int, int> q;
    std::vector<bool> visited(vertexList.size(), false);
    std::vector<int> depth(vertexList.size(), 0);

    Pair<int, int> myPair;
    myPair.key = 1;
    myPair.value = vertexIndex;
    q.push(myPair);
    visited[vertexIndex] = true;

    int count = 1;
    while (!q.empty()) {
        int currentIndex = q.top().value;
        q.pop();
        for (int i = 0; i < vertexList[currentIndex].edges.size(); i++) {
            if (vertexList[currentIndex].edges[i].name == edgeName) {
                int neighborIndex = vertexList[currentIndex].edges[i].endVertexIndex;
                if (!visited[neighborIndex]) {
                    visited[neighborIndex] = true;
                    count++;
                    Pair<int, int> myPair2;
                    myPair2.key = count;
                    myPair2.value = neighborIndex;
                    q.push(myPair2);
                    depth[neighborIndex] = depth[currentIndex] + 1;
                    if (depth[neighborIndex] > maxDepth) {
                        maxDepth = depth[neighborIndex];
                    }
                }
            }
        }
    }

    return maxDepth;
}

// Helper Functions
void MultiGraph::reverseVector(std::vector<int>& vec) const {
    int n = vec.size();
    for (int i = 0; i < n / 2; ++i) {
        int temp = vec[i];
        vec[i] = vec[n - 1 - i];
        vec[n - 1 - i] = temp;
    }
}

int MultiGraph::vertexIndexByName(const std::string& vertexName) const
{
    int vertexIndex = -1;
    for (int i = 0; i < vertexList.size(); i++) {
        if (vertexList[i].name == vertexName) {
            vertexIndex = i;
        }
    }
    return vertexIndex;
}

int MultiGraph::edgeIndexByName(const GraphVertex& vertex, const std::string& edgeName) const
{
    int edgeIndex = -1;
    for(int i = 0; i < vertex.edges.size(); i++) {
        if (vertex.edges[i].name == edgeName) {
            edgeIndex = i;
        }
    }
    return edgeIndex;
}

float MultiGraph::getEdgeWeight(const std::string& edgeName,
                            const std::string& vertexFromName,
                            const std::string& vertexToName, const int weightNo) const
{
    float weight = -1.0;
    
    if(vertexIndexByName(vertexFromName) != -1){
        const GraphVertex& vertex = vertexList[vertexIndexByName(vertexFromName)];
        if(edgeIndexByName(vertex, edgeName) != -1){
            const GraphEdge& edge = vertex.edges[edgeIndexByName(vertex, edgeName)];
            weight = edge.weight[weightNo];
        }
        
    }
    
    return weight;
}

std::string MultiGraph::maxNonVisitedNeighborAirport(std::vector<std::string>& visitedAirports) const 
{
    std::vector<int> nonVisitedNeighborCount(visitedAirports.size(), -1);
    for(int i = 0; i < visitedAirports.size(); i++){
        nonVisitedNeighborCount[i] = getNonVisitedNeighborCount(visitedAirports, visitedAirports[i]); 
    }
    int max = nonVisitedNeighborCount[0];
    int maxIndex = 0;
    for (int i = 1; i < nonVisitedNeighborCount.size(); i++) {
        if (nonVisitedNeighborCount[i] > max) {
            max = nonVisitedNeighborCount[i];
            maxIndex = i;
        }
    }
    return visitedAirports[maxIndex];
}

int MultiGraph::getNonVisitedNeighborCount(std::vector<std::string>& visitedAirports, std::string& airportName) const 
{
    int count = 0;
    int index = vertexIndexByName(airportName);
    std::vector<GraphEdge> edgeList = vertexList[index].edges;
    for(int i = 0; i < edgeList.size(); i++){
        int neighborIndex = edgeList[i].endVertexIndex;
        bool isFound = false;
        for(int j = 0; j < visitedAirports.size(); j++){
            if(vertexList[neighborIndex].name == visitedAirports[j]){
                isFound = true;
                break;
            }
        }
        if(!isFound){
            count++;
        }
    }
    return count;
}

bool MultiGraph::allAirportsVisited(std::vector<std::string>& visitedAirports) const
{
    for (int i = 0; i < vertexList.size(); i++) {
        bool isFound = false;
        for(int j = 0; j < visitedAirports.size(); j++){
            if(visitedAirports[j] == vertexList[i].name){
                isFound = true;
                break;
            }
        }
        if(!isFound){
            return false;
        }
    }
    return true;
}

std::string MultiGraph::getFirstNonUtilizedAirline(std::string& selectedAirport, std::vector<std::string>& visitedAirports, std::vector<std::string>& sisterAirlines) const 
{
    int index = vertexIndexByName(selectedAirport);
    GraphEdge nextAirline;
    for(int i = 0; i < vertexList[index].edges.size(); i++){
        nextAirline = vertexList[index].edges[i];
        bool isFound = false;
        for(int j = 0; j < visitedAirports.size(); j++){
            if(vertexList[nextAirline.endVertexIndex].name == visitedAirports[j]){
                isFound = true;
            }
        }
        for(int t = 0; t < sisterAirlines.size(); t++){
            if(nextAirline.name == sisterAirlines[t]){
                isFound = true;
            }
        }
        if(!isFound){
            return nextAirline.name;
        } 
    }
}

std::vector<std::string> MultiGraph::visitAirportsUsingAirline(std::vector<std::string>& visitedAirports, std::vector<std::string>& sisterAirlines, const std::string& airportName) const
{
    /* TODO */
    int vertexIndex = vertexIndexByName(airportName);
    
    MinPairHeap<int, int> q;
    std::vector<bool> visited(vertexList.size(), false);
    std::vector<std::string> newVisitedAirports;
    
    Pair<int, int> myPair;
    myPair.key = 0;
    myPair.value = vertexIndex;
    q.push(myPair);
    visited[vertexIndex] = true;

    while (!q.empty()) {
        int currentIndex = q.top().value;
        q.pop();
        for (int i = 0; i < vertexList[currentIndex].edges.size(); i++) {
            bool isFound = false;
            for(int t = 0; t < sisterAirlines.size(); t++){
                if(vertexList[currentIndex].edges[i].name == sisterAirlines[t]){
                    isFound = true;
                }
            }
            if (isFound) {
                int neighborIndex = vertexList[currentIndex].edges[i].endVertexIndex;
                if (!visited[neighborIndex]) {
                    visited[neighborIndex] = true;
                    Pair<int, int> myPair2;
                    myPair2.key = 0;
                    myPair2.value = neighborIndex;
                    q.push(myPair2);
                }
            }
        }
    }
    
    for(int i = 0; i < visited.size(); i++){
        bool isFound = false;
        for(int j = 0; j < visitedAirports.size(); j++){
            if(visitedAirports[j] == vertexList[i].name){
                isFound = true;
                break;
            }
        }
        if(visited[i] == true && !isFound){
            newVisitedAirports.push_back(vertexList[i].name);
        }
    }

    return newVisitedAirports;
}
